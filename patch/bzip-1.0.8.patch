--- a/bzip2.1
+++ b/bzip2.1
@@ -1,4 +1,3 @@
-.PU
 .TH bzip2 1
 .SH NAME
 bzip2, bunzip2 \- a block-sorting file compressor, v1.0.8
@@ -18,13 +17,13 @@ bzip2recover \- recovers data from damag
 .br
 .B bunzip2
 .RB [ " \-fkvsVL " ]
-[ 
+[
 .I "filenames \&..."
 ]
 .br
 .B bzcat
 .RB [ " \-s " ]
-[ 
+[
 .I "filenames \&..."
 ]
 .br
@@ -39,15 +38,15 @@ generally considerably better than that
 LZ77/LZ78-based compressors, and approaches the performance of the PPM
 family of statistical compressors.
 
-The command-line options are deliberately very similar to 
-those of 
-.I GNU gzip, 
+The command-line options are deliberately very similar to
+those of
+.I GNU gzip,
 but they are not identical.
 
 .I bzip2
 expects a list of file names to accompany the
 command-line flags.  Each file is replaced by a compressed version of
-itself, with the name "original_name.bz2".  
+itself, with the name "original_name.bz2".
 Each compressed file
 has the same modification date, permissions, and, when possible,
 ownership as the corresponding original, so that these properties can
@@ -74,13 +73,13 @@ incomprehensible and therefore pointless
 
 .I bunzip2
 (or
-.I bzip2 \-d) 
+.I bzip2 \-d)
 decompresses all
-specified files.  Files which were not created by 
+specified files.  Files which were not created by
 .I bzip2
-will be detected and ignored, and a warning issued.  
+will be detected and ignored, and a warning issued.
 .I bzip2
-attempts to guess the filename for the decompressed file 
+attempts to guess the filename for the decompressed file
 from that of the compressed file as follows:
 
        filename.bz2    becomes   filename
@@ -89,13 +88,13 @@ from that of the compressed file as foll
        filename.tbz    becomes   filename.tar
        anyothername    becomes   anyothername.out
 
-If the file does not end in one of the recognised endings, 
-.I .bz2, 
-.I .bz, 
+If the file does not end in one of the recognised endings,
+.I .bz2,
+.I .bz,
 .I .tbz2
 or
-.I .tbz, 
-.I bzip2 
+.I .tbz,
+.I bzip2
 complains that it cannot
 guess the name of the original file, and uses the original name
 with
@@ -103,25 +102,25 @@ with
 appended.
 
 As with compression, supplying no
-filenames causes decompression from 
+filenames causes decompression from
 standard input to standard output.
 
-.I bunzip2 
+.I bunzip2
 will correctly decompress a file which is the
 concatenation of two or more compressed files.  The result is the
 concatenation of the corresponding uncompressed files.  Integrity
-testing (\-t) 
-of concatenated 
+testing (\-t)
+of concatenated
 compressed files is also supported.
 
 You can also compress or decompress files to the standard output by
 giving the \-c flag.  Multiple files may be compressed and
 decompressed like this.  The resulting outputs are fed sequentially to
-stdout.  Compression of multiple files 
+stdout.  Compression of multiple files
 in this manner generates a stream
 containing multiple compressed file representations.  Such a stream
 can be decompressed correctly only by
-.I bzip2 
+.I bzip2
 version 0.9.0 or
 later.  Earlier versions of
 .I bzip2
@@ -130,7 +129,7 @@ the first file in the stream.
 
 .I bzcat
 (or
-.I bzip2 -dc) 
+.I bzip2 -dc)
 decompresses all specified files to
 the standard output.
 
@@ -140,10 +139,10 @@ will read arguments from the environment
 and
 .I BZIP,
 in that order, and will process them
-before any arguments read from the command line.  This gives a 
+before any arguments read from the command line.  This gives a
 convenient way to supply default arguments.
 
-Compression is always performed, even if the compressed 
+Compression is always performed, even if the compressed
 file is slightly
 larger than the original.  Files of less than about one hundred bytes
 tend to get larger, since the compression mechanism has a constant
@@ -151,9 +150,8 @@ overhead in the region of 50 bytes.  Ran
 of most file compressors) is coded at about 8.05 bits per byte, giving
 an expansion of around 0.5%.
 
-As a self-check for your protection, 
-.I 
-bzip2
+As a self-check for your protection,
+.I bzip2
 uses 32-bit CRCs to
 make sure that the decompressed version of a file is identical to the
 original.  This guards against corruption of the compressed data, and
@@ -163,9 +161,9 @@ against undetected bugs in
 chances of data corruption going undetected is microscopic, about one
 chance in four billion for each file processed.  Be aware, though, that
 the check occurs upon decompression, so it can only tell you that
-something is wrong.  It can't help you 
+something is wrong.  It can't help you
 recover the original uncompressed
-data.  You can use 
+data.  You can use
 .I bzip2recover
 to try to recover data from
 damaged files.
@@ -183,15 +181,15 @@ to panic.
 Compress or decompress to standard output.
 .TP
 .B \-d --decompress
-Force decompression.  
-.I bzip2, 
-.I bunzip2 
+Force decompression.
+.I bzip2,
+.I bunzip2
 and
-.I bzcat 
+.I bzcat
 are
 really the same program, and the decision about what actions to take is
 done on the basis of which name is used.  This flag overrides that
-mechanism, and forces 
+mechanism, and forces
 .I bzip2
 to decompress.
 .TP
@@ -205,10 +203,10 @@ This really performs a trial decompressi
 .TP
 .B \-f --force
 Force overwrite of output files.  Normally,
-.I bzip2 
+.I bzip2
 will not overwrite
-existing output files.  Also forces 
-.I bzip2 
+existing output files.  Also forces
+.I bzip2
 to break hard links
 to files, which it otherwise wouldn't do.
 
@@ -224,9 +222,9 @@ or decompression.
 Reduce memory usage, for compression, decompression and testing.  Files
 are decompressed and tested using a modified algorithm which only
 requires 2.5 bytes per block byte.  This means any file can be
-decompressed in 2300k of memory, albeit at about half the normal speed.
+decompressed in 2300\ k of memory, albeit at about half the normal speed.
 
-During compression, \-s selects a block size of 200k, which limits
+During compression, \-s selects a block size of 200\ k, which limits
 memory use to around the same figure, at the expense of your compression
 ratio.  In short, if your machine is low on memory (8 megabytes or
 less), use \-s for everything.  See MEMORY MANAGEMENT below.
@@ -244,11 +242,11 @@ information which is primarily of intere
 Display the software version, license terms and conditions.
 .TP
 .B \-1 (or \-\-fast) to \-9 (or \-\-best)
-Set the block size to 100 k, 200 k ..  900 k when compressing.  Has no
+Set the block size to 100 k, 200 k ...  900 k when compressing.  Has no
 effect when decompressing.  See MEMORY MANAGEMENT below.
-The \-\-fast and \-\-best aliases are primarily for GNU gzip 
+The \-\-fast and \-\-best aliases are primarily for GNU gzip
 compatibility.  In particular, \-\-fast doesn't make things
-significantly faster.  
+significantly faster.
 And \-\-best merely selects the default behaviour.
 .TP
 .B \--
@@ -263,7 +261,7 @@ earlier versions, which was sometimes us
 improved algorithm which renders these flags irrelevant.
 
 .SH MEMORY MANAGEMENT
-.I bzip2 
+.I bzip2
 compresses large files in blocks.  The block size affects
 both the compression ratio achieved, and the amount of memory needed for
 compression and decompression.  The flags \-1 through \-9
@@ -276,13 +274,13 @@ the file.  Since block sizes are stored
 that the flags \-1 to \-9 are irrelevant to and so ignored
 during decompression.
 
-Compression and decompression requirements, 
+Compression and decompression requirements,
 in bytes, can be estimated as:
 
-       Compression:   400k + ( 8 x block size )
+       Compression:   400\ k + ( 8 x block size )
 
-       Decompression: 100k + ( 4 x block size ), or
-                      100k + ( 2.5 x block size )
+       Decompression: 100\ k + ( 4 x block size ), or
+                      100\ k + ( 2.5 x block size )
 
 Larger block sizes give rapidly diminishing marginal returns.  Most of
 the compression comes from the first two or three hundred k of block
@@ -292,10 +290,10 @@ on small machines.
 It is also important to appreciate that the decompression memory
 requirement is set at compression time by the choice of block size.
 
-For files compressed with the default 900k block size,
+For files compressed with the default 900\ k block size,
 .I bunzip2
 will require about 3700 kbytes to decompress.  To support decompression
-of any file on a 4 megabyte machine, 
+of any file on a 4 megabyte machine,
 .I bunzip2
 has an option to
 decompress using approximately half this amount of memory, about 2300
@@ -311,9 +309,9 @@ Another significant point applies to fil
 amount of real memory touched is proportional to the size of the file,
 since the file is smaller than a block.  For example, compressing a file
 20,000 bytes long with the flag -9 will cause the compressor to
-allocate around 7600k of memory, but only touch 400k + 20000 * 8 = 560
-kbytes of it.  Similarly, the decompressor will allocate 3700k but only
-touch 100k + 20000 * 4 = 180 kbytes.
+allocate around 7600\ k of memory, but only touch 400\ k + 20000 * 8 = 560
+kbytes of it.  Similarly, the decompressor will allocate 3700\ k but only
+touch 100\ k + 20000 * 4 = 180 kbytes.
 
 Here is a table which summarises the maximum memory usage for different
 block sizes.  Also recorded is the total compressed size for 14 files of
@@ -337,7 +335,7 @@ larger files, since the Corpus is domina
 
 .SH RECOVERING DATA FROM DAMAGED FILES
 .I bzip2
-compresses files in blocks, usually 900kbytes long.  Each
+compresses files in blocks, usually 900\ kbytes long.  Each
 block is handled independently.  If a media or transmission error causes
 a multi-block .bz2
 file to become damaged, it may be possible to
@@ -350,36 +348,36 @@ damaged blocks can be distinguished from
 
 .I bzip2recover
 is a simple program whose purpose is to search for
-blocks in .bz2 files, and write each block out into its own .bz2 
+blocks in .bz2 files, and write each block out into its own .bz2
 file.  You can then use
-.I bzip2 
+.I bzip2
 \-t
 to test the
 integrity of the resulting files, and decompress those which are
 undamaged.
 
 .I bzip2recover
-takes a single argument, the name of the damaged file, 
+takes a single argument, the name of the damaged file,
 and writes a number of files "rec00001file.bz2",
-"rec00002file.bz2", etc, containing the  extracted  blocks.
-The  output  filenames  are  designed  so  that the use of
-wildcards in subsequent processing -- for example,  
-"bzip2 -dc  rec*file.bz2 > recovered_data" -- processes the files in
+"rec00002file.bz2", etc., containing the  extracted  blocks.
+The output filenames are designed so that the use of
+wildcards in subsequent processing -- for example,
+"bzip2 -dc rec*file.bz2 > recovered_data" -- processes the files in
 the correct order.
 
 .I bzip2recover
 should be of most use dealing with large .bz2
-files,  as  these will contain many blocks.  It is clearly
-futile to use it on damaged single-block  files,  since  a
-damaged  block  cannot  be recovered.  If you wish to minimise 
-any potential data loss through media  or  transmission errors, 
+files, as these will contain many blocks.  It is clearly
+futile to use it on damaged single-block files, since a
+damaged block cannot be recovered.  If you wish to minimise
+any potential data loss through media or transmission errors,
 you might consider compressing with a smaller
 block size.
 
 .SH PERFORMANCE NOTES
 The sorting phase of compression gathers together similar strings in the
 file.  Because of this, files containing very long runs of repeated
-symbols, like "aabaabaabaab ..."  (repeated several hundred times) may
+symbols, like "aabaabaabaab ...\&" (repeated several hundred times) may
 compress more slowly than normal.  Versions 0.9.5 and above fare much
 better than previous versions in this respect.  The ratio between
 worst-case and average-case compression time is in the region of 10:1.
@@ -395,7 +393,7 @@ that performance, both for compressing a
 determined by the speed at which your machine can service cache misses.
 Because of this, small changes to the code to reduce the miss rate have
 been observed to give disproportionately large performance improvements.
-I imagine 
+I imagine
 .I bzip2
 will perform best on machines with very large caches.
 
@@ -406,7 +404,7 @@ tries hard to detect I/O errors and exit
 what the problem is sometimes seem rather misleading.
 
 This manual page pertains to version 1.0.8 of
-.I bzip2.  
+.I bzip2.
 Compressed data created by this version is entirely forwards and
 backwards compatible with the previous public releases, versions
 0.1pl2, 0.9.0, 0.9.5, 1.0.0, 1.0.1, 1.0.2 and above, but with the following
@@ -440,13 +438,13 @@ Fenwick (for the structured coding model
 .I bzip,
 and many refinements), and Alistair Moffat, Radford Neal and Ian Witten
 (for the arithmetic coder in the original
-.I bzip).  
+.I bzip).
 I am much
 indebted for their help, support and advice.  See the manual in the
 source distribution for pointers to sources of documentation.  Christian
 von Roques encouraged me to look for faster sorting algorithms, so as to
 speed up compression.  Bela Lubkin encouraged me to improve the
-worst-case compression performance.  
+worst-case compression performance.
 Donna Robinson XMLised the documentation.
 The bz* scripts are derived from those of GNU gzip.
 Many people sent patches, helped


--- a/bzgrep
+++ b/bzgrep
@@ -1,27 +1,75 @@
 #!/bin/sh
 
-# Bzgrep wrapped for bzip2, 
-# adapted from zgrep by Philippe Troin <phil@fifi.org> for Debian GNU/Linux.
-## zgrep notice:
-## zgrep -- a wrapper around a grep program that decompresses files as needed
-## Adapted from a version sent by Charles Levert <charles@comm.polymtl.ca>
+# bzgrep -- a wrapper around a grep program that decompresses files as needed
+# Adapted from zgrep of the Debian gzip package by Anibal Monsalve Salazar.
+# Adapted from a version sent by Charles Levert <charles@comm.polymtl.ca>
+
+# Copyright (C) 1998, 2001, 2002 Free Software Foundation
+# Copyright (C) 1993 Jean-loup Gailly
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+# 02111-1307, USA.
 
 PATH="/usr/bin:$PATH"; export PATH
 
-prog=`echo $0 | sed 's|.*/||'`
+prog=`echo "$0" | sed 's|.*/||'`
 case "$prog" in
 	*egrep)	grep=${EGREP-egrep}	;;
 	*fgrep)	grep=${FGREP-fgrep}	;;
 	*)	grep=${GREP-grep}	;;
 esac
+
 pat=""
+after_dash_dash=""
+files_with_matches=0
+files_without_matches=0
+no_filename=0
+with_filename=0
+
 while test $# -ne 0; do
-  case "$1" in
-  -e | -f) opt="$opt $1"; shift; pat="$1"
+  case "$after_dash_dash$1" in
+  --d* | --rec*)	echo >&2 "$0: $1: option not supported"; exit 2;;
+  --files-with-*)	files_with_matches=1;;
+  --files-witho*)	files_without_matches=1;;
+  --no-f*)	no_filename=1;;
+  --wi*)	with_filename=1;;
+  --*)	;;
+  -*)
+	case "$1" in
+	-*[dr]*) echo >&2 "$0: $1: option not supported"; exit 2;;
+	esac
+	case "$1" in
+	-*H*)	with_filename=1;;
+	esac
+	case "$1" in
+	-*h*)	no_filename=1;;
+	esac
+	case "$1" in
+	-*L*)	files_without_matches=1;;
+	esac
+	case "$1" in
+	-*l*)	files_with_matches=1;;
+	esac;;
+  esac
+  case "$after_dash_dash$1" in
+  -[ef])   opt="$opt $1"; shift; pat="$1"
            if test "$grep" = grep; then  # grep is buggy with -e on SVR4
              grep=egrep
            fi;;
-  -A | -B) opt="$opt $1 $2"; shift;;
+  -[ABCdm])opt="$opt $1 $2"; shift;;
+  --)      opt="$opt $1"; after_dash_dash=1;;
   -*)	   opt="$opt $1";;
    *)      if test -z "$pat"; then
 	     pat="$1"
@@ -35,19 +83,9 @@ done
 if test -z "$pat"; then
   echo "grep through bzip2 files"
   echo "usage: $prog [grep_options] pattern [files]"
-  exit 1
+  exit 2
 fi
 
-list=0
-silent=0
-op=`echo "$opt" | sed -e 's/ //g' -e 's/-//g'`
-case "$op" in
-  *l*) list=1
-esac
-case "$op" in
-  *h*) silent=1
-esac
-
 if test $# -eq 0; then
   bzip2 -cdfq | $grep $opt "$pat"
   exit $?
@@ -56,30 +94,40 @@ fi
 res=0
 for i do
   if test -f "$i"; then :; else if test -f "$i.bz2"; then i="$i.bz2"; fi; fi
-  if test $list -eq 1; then
-    bzip2 -cdfq "$i" | $grep $opt "$pat" 2>&1 > /dev/null && echo $i
-    r=$?
-  elif test $# -eq 1 -o $silent -eq 1; then
-    bzip2 -cdfq "$i" | $grep $opt "$pat"
-    r=$?
-  else
-    j=$(echo "$i" | sed 's/\\/&&/g;s/|/\\&/g;s/&/\\&/g')
-    j=`printf "%s" "$j" | tr '\n' ' '`
-    # A trick adapted from
-    # https://groups.google.com/forum/#!original/comp.unix.shell/x1345iu10eg/Nn1n-1r1uU0J
-    # that has the same effect as the following bash code:
-    # bzip2 -cdfq "$i" | $grep $opt "$pat" | sed "s|^|${j}:|"
-    # r=${PIPESTATUS[1]}
-    exec 3>&1
-    eval `
+  bzip2 -cdfq -- "$i" |
+    if test $files_with_matches -eq 1; then
+      $grep $opt "$pat" > /dev/null && printf "%s\n" "$i"
+    elif test $files_without_matches -eq 1; then
+      $grep $opt "$pat" > /dev/null || printf "%s\n" "$i"
+    elif test $with_filename -eq 0 && { test $# -eq 1 || test $no_filename -eq 1; }; then
+      $grep $opt "$pat"
+    else
+      i=$(echo "$i" | sed -e 's/[\\|&]/\\&/g')
+      if test $with_filename -eq 1; then
+        sed_script="s|^[^:]*:|${i}:|"
+      else
+        sed_script="s|^|${i}:|"
+      fi
+      # Hack adapted from GPLed code at
+      # https://groups.google.com/forum/#!original/comp.unix.shell/x1345iu10eg/Nn1n-1r1uU0J
+      # Has the same effect as the following two lines of bash:
+      #
+      # $grep $opt "$pat" | sed "$sed_script"
+      # exit ${PIPESTATUS[0]}
+      #
+      # Inside the `...`, fd4 goes to the pipe whose other end is read
+      # and passed to eval; fd1 is the normal standard output
+      # preserved the line before with exec 3>&1
+      exec 3>&1
+      eval `
       exec 4>&1 >&3 3>&-
       {
-        bzip2 -cdfq "$i" 4>&-
-      } | {
-        $grep $opt "$pat" 4>&-; echo "r=$?;" >&4
-      } | sed "s|^|${j}:|"
-    `
-  fi
-  test "$r" -ne 0 && res="$r"
+       $grep $opt "$pat" 4>&-; echo "r=$?;" >&4
+      } | sed "$sed_script"
+      `
+      exit $r
+    fi
+  r=$?
+  test $res -lt $r && res=$r
 done
 exit $res
Index: bzip2/bzmore
===================================================================
--- a/bzmore
+++ b/bzmore
@@ -24,10 +24,10 @@ else
   # 'stty min 1' resets eof to ^a on both SunOS and SysV!
   cb='min 1 -icanon'; ncb='icanon eof ^d'
 fi
-if test $? -eq 0 -a -n "$oldtty"; then
-   trap 'stty $oldtty 2>/dev/null; exit' 0 2 3 5 10 13 15
+if test $? -eq 0 && test -n "$oldtty"; then
+   trap 'stty $oldtty 2>/dev/null; exit' 0 INT QUIT TRAP USR1 PIPE TERM
 else
-   trap 'stty $ncb echo 2>/dev/null; exit' 0 2 3 5 10 13 15
+   trap 'stty $ncb echo 2>/dev/null; exit' 0 INT QUIT TRAP USR1 PIPE TERM
 fi
 
 if test $# = 0; then
@@ -46,7 +46,7 @@ else
 		ANS=`dd bs=1 count=1 2>/dev/null` 
 		stty $ncb echo 2>/dev/null
 		echo " "
-		if test "$ANS" = 'e' -o "$ANS" = 'q'; then
+		if test "$ANS" = 'e' || test "$ANS" = 'q'; then
 			exit
 		fi
 	fi
Index: bzip2/bzip2.c
===================================================================
--- a/bzip2.c
+++ b/bzip2.c
@@ -1890,7 +1890,9 @@ IntNative main ( IntNative argc, Char *a
                case '8': blockSize100k    = 8; break;
                case '9': blockSize100k    = 9; break;
                case 'V':
-               case 'L': license();            break;
+               case 'L': license();
+			 exit ( 0 );
+			 break;
                case 'v': verbosity++; break;
                case 'h': usage ( progName );
                          exit ( 0 );
@@ -1916,8 +1918,8 @@ IntNative main ( IntNative argc, Char *a
       if (ISFLAG("--keep"))              keepInputFiles   = True;    else
       if (ISFLAG("--small"))             smallMode        = True;    else
       if (ISFLAG("--quiet"))             noisy            = False;   else
-      if (ISFLAG("--version"))           license();                  else
-      if (ISFLAG("--license"))           license();                  else
+      if (ISFLAG("--version"))           { license(); exit ( 0 ); }  else
+      if (ISFLAG("--license"))           { license(); exit ( 0 ); }  else
       if (ISFLAG("--exponential"))       workFactor = 1;             else 
       if (ISFLAG("--repetitive-best"))   redundant(aa->name);        else
       if (ISFLAG("--repetitive-fast"))   redundant(aa->name);        else


--- a/manual.xml
+++ b/manual.xml
@@ -1162,9 +1162,9 @@
   if the library has been mis-compiled
 BZ_PARAM_ERROR
   if strm is NULL 
-  or blockSize < 1 or blockSize > 9
-  or verbosity < 0 or verbosity > 4
-  or workFactor < 0 or workFactor > 250
+  or blockSize &lt; 1 or blockSize &gt; 9
+  or verbosity &lt; 0 or verbosity &gt; 4
+  or workFactor &lt; 0 or workFactor &gt; 250
 BZ_MEM_ERROR 
   if not enough memory is available
 BZ_OK 
@@ -1474,8 +1474,8 @@
 BZ_CONFIG_ERROR
   if the library has been mis-compiled
 BZ_PARAM_ERROR
-  if ( small != 0 && small != 1 )
-  or (verbosity <; 0 || verbosity > 4)
+  if ( small != 0 &amp;&amp; small != 1 )
+  or (verbosity &lt; 0 || verbosity &gt; 4)
 BZ_MEM_ERROR
   if insufficient memory is available
 </programlisting>
@@ -1560,7 +1560,7 @@
 <programlisting>
 BZ_PARAM_ERROR
   if strm is NULL or strm->s is NULL
-  or strm->avail_out < 1
+  or strm->avail_out &lt; 1
 BZ_DATA_ERROR
   if a data integrity error is detected in the compressed stream
 BZ_DATA_ERROR_MAGIC
@@ -1733,8 +1733,8 @@
 BZ_PARAM_ERROR
   if f is NULL
   or small is neither 0 nor 1
-  or ( unused == NULL && nUnused != 0 )
-  or ( unused != NULL && !(0 <= nUnused <= BZ_MAX_UNUSED) )
+  or ( unused == NULL &amp;&amp; nUnused != 0 )
+  or ( unused != NULL &amp;&amp; !(0 &lt;= nUnused &lt;= BZ_MAX_UNUSED) )
 BZ_IO_ERROR
   if ferror(f) is nonzero
 BZ_MEM_ERROR
@@ -1813,7 +1813,7 @@
 
 <programlisting>
 BZ_PARAM_ERROR
-  if b is NULL or buf is NULL or len < 0
+  if b is NULL or buf is NULL or len &lt; 0
 BZ_SEQUENCE_ERROR
   if b was opened with BZ2_bzWriteOpen
 BZ_IO_ERROR
@@ -1971,7 +1971,7 @@
   if the library has been mis-compiled
 BZ_PARAM_ERROR
   if f is NULL
-  or blockSize100k < 1 or blockSize100k > 9
+  or blockSize100k &lt; 1 or blockSize100k &gt; 9
 BZ_IO_ERROR
   if ferror(f) is nonzero
 BZ_MEM_ERROR
@@ -2018,7 +2018,7 @@
 
 <programlisting>
 BZ_PARAM_ERROR
-  if b is NULL or buf is NULL or len < 0
+  if b is NULL or buf is NULL or len &lt; 0
 BZ_SEQUENCE_ERROR
   if b was opened with BZ2_bzReadOpen
 BZ_IO_ERROR
@@ -2169,7 +2169,7 @@
 if ( !f ) {
  /* handle error */
 }
-b = BZ2_bzWriteOpen( &bzerror, f, 9 );
+b = BZ2_bzWriteOpen( &amp;bzerror, f, 9 );
 if (bzerror != BZ_OK) {
  BZ2_bzWriteClose ( b );
  /* handle error */
@@ -2177,14 +2177,14 @@
 
 while ( /* condition */ ) {
  /* get data to write into buf, and set nBuf appropriately */
- nWritten = BZ2_bzWrite ( &bzerror, b, buf, nBuf );
+ nWritten = BZ2_bzWrite ( &amp;bzerror, b, buf, nBuf );
  if (bzerror == BZ_IO_ERROR) { 
-   BZ2_bzWriteClose ( &bzerror, b );
+   BZ2_bzWriteClose ( &amp;bzerror, b );
    /* handle error */
  }
 }
 
-BZ2_bzWriteClose( &bzerror, b );
+BZ2_bzWriteClose( &amp;bzerror, b );
 if (bzerror == BZ_IO_ERROR) {
  /* handle error */
 }
@@ -2204,24 +2204,24 @@
 if ( !f ) {
   /* handle error */
 }
-b = BZ2_bzReadOpen ( &bzerror, f, 0, NULL, 0 );
+b = BZ2_bzReadOpen ( &amp;bzerror, f, 0, NULL, 0 );
 if ( bzerror != BZ_OK ) {
-  BZ2_bzReadClose ( &bzerror, b );
+  BZ2_bzReadClose ( &amp;bzerror, b );
   /* handle error */
 }
 
 bzerror = BZ_OK;
-while ( bzerror == BZ_OK && /* arbitrary other conditions */) {
-  nBuf = BZ2_bzRead ( &bzerror, b, buf, /* size of buf */ );
+while ( bzerror == BZ_OK &amp;&amp; /* arbitrary other conditions */) {
+  nBuf = BZ2_bzRead ( &amp;bzerror, b, buf, /* size of buf */ );
   if ( bzerror == BZ_OK ) {
     /* do something with buf[0 .. nBuf-1] */
   }
 }
 if ( bzerror != BZ_STREAM_END ) {
-   BZ2_bzReadClose ( &bzerror, b );
+   BZ2_bzReadClose ( &amp;bzerror, b );
    /* handle error */
 } else {
-   BZ2_bzReadClose ( &bzerror, b );
+   BZ2_bzReadClose ( &amp;bzerror, b );
 }
 </programlisting>
 
@@ -2287,9 +2287,9 @@
   if the library has been mis-compiled
 BZ_PARAM_ERROR
   if dest is NULL or destLen is NULL
-  or blockSize100k < 1 or blockSize100k > 9
-  or verbosity < 0 or verbosity > 4
-  or workFactor < 0 or workFactor > 250
+  or blockSize100k &lt; 1 or blockSize100k &gt; 9
+  or verbosity &lt; 0 or verbosity &gt; 4
+  or workFactor &lt; 0 or workFactor &gt; 250
 BZ_MEM_ERROR
   if insufficient memory is available 
 BZ_OUTBUFF_FULL
@@ -2355,8 +2355,8 @@
   if the library has been mis-compiled
 BZ_PARAM_ERROR
   if dest is NULL or destLen is NULL
-  or small != 0 && small != 1
-  or verbosity < 0 or verbosity > 4
+  or small != 0 &amp;&amp; small != 1
+  or verbosity &lt; 0 or verbosity &gt; 4
 BZ_MEM_ERROR
   if insufficient memory is available 
 BZ_OUTBUFF_FULL


--- a/manual.xml
+++ b/manual.xml
@@ -160,12 +160,21 @@
  <listitem><para><computeroutput>bzip2</computeroutput> [
   -cdfkqstvzVL123456789 ] [ filenames ...  ]</para></listitem>
 
+ <listitem><para><computeroutput>bzip2</computeroutput> [
+  -h | --help ]</para></listitem>
+
  <listitem><para><computeroutput>bunzip2</computeroutput> [
   -fkvsVL ] [ filenames ...  ]</para></listitem>
 
+ <listitem><para><computeroutput>bunzip2</computeroutput> [
+  -h | --help ]</para></listitem>
+
  <listitem><para><computeroutput>bzcat</computeroutput> [ -s ] [
   filenames ...  ]</para></listitem>
 
+ <listitem><para><computeroutput>bzcat</computeroutput> [
+  -h | --help ]</para></listitem>
+
  <listitem><para><computeroutput>bzip2recover</computeroutput>
   filename</para></listitem>
 
@@ -397,6 +406,10 @@
   will not be suppressed.</para></listitem>
  </varlistentry>
 
+ <varlistentry><term><computeroutput>-h --help</computeroutput></term>
+ <listitem><para>Print a help message and exit.</para></listitem>
+ </varlistentry>
+
  <varlistentry>
  <term><computeroutput>-v --verbose</computeroutput></term>
  <listitem><para>Verbose mode -- show the compression ratio for
--- a/bzip2.1
+++ b/bzip2.1
@@ -13,6 +13,9 @@
 [
 .I "filenames \&..."
 ]
+.br
+.B bzip2
+.RB [ " \-h|\-\-help " ]
 .ll -8
 .br
 .B bunzip2
@@ -21,12 +24,18 @@
 .I "filenames \&..."
 ]
 .br
+.B bunzip2
+.RB [ " \-h|\-\-help " ]
+.br
 .B bzcat
 .RB [ " \-s " ]
 [
 .I "filenames \&..."
 ]
 .br
+.B bzcat
+.RB [ " \-h|\-\-help " ]
+.br
 .B bzip2recover
 .I "filename"
 
@@ -238,6 +247,9 @@
 Further \-v's increase the verbosity level, spewing out lots of
 information which is primarily of interest for diagnostic purposes.
 .TP
+.B \-h \-\-help
+Print a help message and exit.
+.TP
 .B \-L --license -V --version
 Display the software version, license terms and conditions.
 .TP


--- a/Makefile
+++ b/Makefile
@@ -12,6 +12,8 @@
 # in the file LICENSE.
 # ------------------------------------------------------------------
 
+somajor=1.0
+sominor=$(somajor).4
 SHELL=/bin/sh
 
 # To assist in cross-compiling
@@ -37,29 +39,50 @@
 
 all: libbz2.a bzip2 bzip2recover test
 
-bzip2: libbz2.a bzip2.o
-	$(CC) $(CFLAGS) $(LDFLAGS) -o bzip2 bzip2.o -L. -lbz2
+bzip2: libbz2.so bzip2.o
+	$(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) -o bzip2 bzip2.o -L. -lbz2
 
 bzip2recover: bzip2recover.o
-	$(CC) $(CFLAGS) $(LDFLAGS) -o bzip2recover bzip2recover.o
+	$(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) -o bzip2recover bzip2recover.o
 
 libbz2.a: $(OBJS)
 	rm -f libbz2.a
 	$(AR) cq libbz2.a $(OBJS)
-	@if ( test -f $(RANLIB) -o -f /usr/bin/ranlib -o \
-		-f /bin/ranlib -o -f /usr/ccs/bin/ranlib ) ; then \
+	@if ( test -f $(RANLIB) || test -f /usr/bin/ranlib || \
+		test -f /bin/ranlib || test -f /usr/ccs/bin/ranlib ) ; then \
 		echo $(RANLIB) libbz2.a ; \
 		$(RANLIB) libbz2.a ; \
 	fi
 
+libbz2.so: libbz2.so.$(somajor)
+	ln -sf $^ $@
+
+libbz2.so.$(somajor): libbz2.so.$(sominor)
+	ln -sf $^ $@
+
+libbz2.so.$(sominor): $(OBJS:%.o=%.sho)
+	$(CC) -o libbz2.so.$(sominor) -shared $(LDFLAGS) \
+	  -Wl,-soname,libbz2.so.$(somajor) $^ -lc
+
+$(OBJS:%.o=%.sho) bzip2.sho bzip2recover.sho: %.sho: %.c
+	$(CC) $(CFLAGS) $(CPPFLAGS) -fPIC -o $@ -c $<
+$(OBJS) bzip2.o bzip2recover.o: %.o: %.c
+	$(CC) $(CFLAGS) $(CPPFLAGS) -o $@ -c $<
+
 check: test
 test: bzip2
 	@cat words1
+	LD_LIBRARY_PATH=.:$$LD_LIBRARY_PATH \
 	./bzip2 -1  < sample1.ref > sample1.rb2
+	LD_LIBRARY_PATH=.:$$LD_LIBRARY_PATH \
 	./bzip2 -2  < sample2.ref > sample2.rb2
+	LD_LIBRARY_PATH=.:$$LD_LIBRARY_PATH \
 	./bzip2 -3  < sample3.ref > sample3.rb2
+	LD_LIBRARY_PATH=.:$$LD_LIBRARY_PATH \
 	./bzip2 -d  < sample1.bz2 > sample1.tst
+	LD_LIBRARY_PATH=.:$$LD_LIBRARY_PATH \
 	./bzip2 -d  < sample2.bz2 > sample2.tst
+	LD_LIBRARY_PATH=.:$$LD_LIBRARY_PATH \
 	./bzip2 -ds < sample3.bz2 > sample3.tst
 	cmp sample1.bz2 sample1.rb2 
 	cmp sample2.bz2 sample2.rb2
@@ -69,15 +92,15 @@
 	cmp sample3.tst sample3.ref
 	@cat words3
 
-install: bzip2 bzip2recover
+install: bzip2 bzip2recover libbz2.a
 	if ( test ! -d $(PREFIX)/bin ) ; then mkdir -p $(PREFIX)/bin ; fi
 	if ( test ! -d $(PREFIX)/lib ) ; then mkdir -p $(PREFIX)/lib ; fi
 	if ( test ! -d $(PREFIX)/man ) ; then mkdir -p $(PREFIX)/man ; fi
 	if ( test ! -d $(PREFIX)/man/man1 ) ; then mkdir -p $(PREFIX)/man/man1 ; fi
 	if ( test ! -d $(PREFIX)/include ) ; then mkdir -p $(PREFIX)/include ; fi
 	cp -f bzip2 $(PREFIX)/bin/bzip2
-	cp -f bzip2 $(PREFIX)/bin/bunzip2
-	cp -f bzip2 $(PREFIX)/bin/bzcat
+	ln -s -f $(PREFIX)/bin/bzip2 $(PREFIX)/bin/bunzip2
+	ln -s -f $(PREFIX)/bin/bzip2 $(PREFIX)/bin/bzcat
 	cp -f bzip2recover $(PREFIX)/bin/bzip2recover
 	chmod a+x $(PREFIX)/bin/bzip2
 	chmod a+x $(PREFIX)/bin/bunzip2
@@ -87,7 +110,7 @@
 	chmod a+r $(PREFIX)/man/man1/bzip2.1
 	cp -f bzlib.h $(PREFIX)/include
 	chmod a+r $(PREFIX)/include/bzlib.h
-	cp -f libbz2.a $(PREFIX)/lib
+	cp -fa libbz2.a libbz2.so* $(PREFIX)/lib
 	chmod a+r $(PREFIX)/lib/libbz2.a
 	cp -f bzgrep $(PREFIX)/bin/bzgrep
 	ln -s -f $(PREFIX)/bin/bzgrep $(PREFIX)/bin/bzegrep
@@ -109,30 +132,10 @@
 	echo ".so man1/bzdiff.1" > $(PREFIX)/man/man1/bzcmp.1
 
 clean: 
-	rm -f *.o libbz2.a bzip2 bzip2recover \
+	rm -f *.o *.sho libbz2.a libbz2.so* bzip2 bzip2recover \
 	sample1.rb2 sample2.rb2 sample3.rb2 \
 	sample1.tst sample2.tst sample3.tst
 
-blocksort.o: blocksort.c
-	@cat words0
-	$(CC) $(CFLAGS) -c blocksort.c
-huffman.o: huffman.c
-	$(CC) $(CFLAGS) -c huffman.c
-crctable.o: crctable.c
-	$(CC) $(CFLAGS) -c crctable.c
-randtable.o: randtable.c
-	$(CC) $(CFLAGS) -c randtable.c
-compress.o: compress.c
-	$(CC) $(CFLAGS) -c compress.c
-decompress.o: decompress.c
-	$(CC) $(CFLAGS) -c decompress.c
-bzlib.o: bzlib.c
-	$(CC) $(CFLAGS) -c bzlib.c
-bzip2.o: bzip2.c
-	$(CC) $(CFLAGS) -c bzip2.c
-bzip2recover.o: bzip2recover.c
-	$(CC) $(CFLAGS) -c bzip2recover.c
-
 
 distclean: clean
 	rm -f manual.ps manual.html manual.pdf


--- a/bzip2recover.c
+++ b/bzip2recover.c
@@ -24,6 +24,8 @@
 #include <errno.h>
 #include <stdlib.h>
 #include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
 
 
 /* This program records bit locations in the file to be recovered.
@@ -269,6 +271,19 @@ static Bool endsInBz2 ( Char* name )
        name[n-1] == '2');
 }
 
+/*---------------------------------------------*/
+/* Open an output file safely with O_EXCL and good permissions */
+FILE* fopen_output( Char* name, const char* mode )
+{
+  FILE *fp;
+  int   fh;
+
+  fh = open(name, O_WRONLY|O_CREAT|O_EXCL, 0600);
+  if (fh == -1) return NULL;
+  fp = fdopen(fh, mode);
+  if (fp == NULL) close(fh);
+  return fp;
+}
 
 /*---------------------------------------------------*/
 /*---                                             ---*/
@@ -488,7 +503,7 @@ Int32 main ( Int32 argc, Char** argv )
          fprintf ( stderr, "   writing block %d to `%s' ...\n",
                            wrBlock+1, outFileName );
 
-         outFile = fopen ( outFileName, "wb" );
+         outFile = fopen_output ( outFileName, "wb" );
          if (outFile == NULL) {
             fprintf ( stderr, "%s: can't write `%s'\n",
                       progName, outFileName );


--- a/bzdiff
+++ b/bzdiff
@@ -24,7 +24,11 @@ FILES=
 for ARG
 do
     case "$ARG" in
-    -*)	OPTIONS="$OPTIONS $ARG";;
+    -*)	if test -z "$OPTIONS"; then
+	    OPTIONS="$ARG"
+        else
+            OPTIONS="$OPTIONS $ARG"
+        fi ;;
      *)	if test -f "$ARG"; then
             FILES="$FILES $ARG"
         else
